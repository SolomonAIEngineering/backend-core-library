package message_definitionv1

import (
	context "context"
	gorm1 "github.com/infobloxopen/atlas-app-toolkit/gorm"
	errors "github.com/infobloxopen/protoc-gen-gorm/errors"
	gorm "github.com/jinzhu/gorm"
	field_mask "google.golang.org/genproto/protobuf/field_mask"
)

type HeadlessAuthenticationServiceDeleteAccountMessageFormatORM struct {
	AuthnId uint64
	Email   string
}

// TableName overrides the default tablename generated by GORM
func (HeadlessAuthenticationServiceDeleteAccountMessageFormatORM) TableName() string {
	return "headless_authentication_service_delete_account_message_formats"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *HeadlessAuthenticationServiceDeleteAccountMessageFormat) ToORM(ctx context.Context) (HeadlessAuthenticationServiceDeleteAccountMessageFormatORM, error) {
	to := HeadlessAuthenticationServiceDeleteAccountMessageFormatORM{}
	var err error
	if prehook, ok := interface{}(m).(HeadlessAuthenticationServiceDeleteAccountMessageFormatWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.AuthnId = m.AuthnId
	to.Email = m.Email
	if posthook, ok := interface{}(m).(HeadlessAuthenticationServiceDeleteAccountMessageFormatWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *HeadlessAuthenticationServiceDeleteAccountMessageFormatORM) ToPB(ctx context.Context) (HeadlessAuthenticationServiceDeleteAccountMessageFormat, error) {
	to := HeadlessAuthenticationServiceDeleteAccountMessageFormat{}
	var err error
	if prehook, ok := interface{}(m).(HeadlessAuthenticationServiceDeleteAccountMessageFormatWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.AuthnId = m.AuthnId
	to.Email = m.Email
	if posthook, ok := interface{}(m).(HeadlessAuthenticationServiceDeleteAccountMessageFormatWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type HeadlessAuthenticationServiceDeleteAccountMessageFormat the arg will be the target, the caller the one being converted from

// HeadlessAuthenticationServiceDeleteAccountMessageFormatBeforeToORM called before default ToORM code
type HeadlessAuthenticationServiceDeleteAccountMessageFormatWithBeforeToORM interface {
	BeforeToORM(context.Context, *HeadlessAuthenticationServiceDeleteAccountMessageFormatORM) error
}

// HeadlessAuthenticationServiceDeleteAccountMessageFormatAfterToORM called after default ToORM code
type HeadlessAuthenticationServiceDeleteAccountMessageFormatWithAfterToORM interface {
	AfterToORM(context.Context, *HeadlessAuthenticationServiceDeleteAccountMessageFormatORM) error
}

// HeadlessAuthenticationServiceDeleteAccountMessageFormatBeforeToPB called before default ToPB code
type HeadlessAuthenticationServiceDeleteAccountMessageFormatWithBeforeToPB interface {
	BeforeToPB(context.Context, *HeadlessAuthenticationServiceDeleteAccountMessageFormat) error
}

// HeadlessAuthenticationServiceDeleteAccountMessageFormatAfterToPB called after default ToPB code
type HeadlessAuthenticationServiceDeleteAccountMessageFormatWithAfterToPB interface {
	AfterToPB(context.Context, *HeadlessAuthenticationServiceDeleteAccountMessageFormat) error
}

type FinancialIntegrationServiceMessageFormatORM struct {
	UserId uint64
}

// TableName overrides the default tablename generated by GORM
func (FinancialIntegrationServiceMessageFormatORM) TableName() string {
	return "financial_integration_service_message_formats"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *FinancialIntegrationServiceMessageFormat) ToORM(ctx context.Context) (FinancialIntegrationServiceMessageFormatORM, error) {
	to := FinancialIntegrationServiceMessageFormatORM{}
	var err error
	if prehook, ok := interface{}(m).(FinancialIntegrationServiceMessageFormatWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(FinancialIntegrationServiceMessageFormatWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *FinancialIntegrationServiceMessageFormatORM) ToPB(ctx context.Context) (FinancialIntegrationServiceMessageFormat, error) {
	to := FinancialIntegrationServiceMessageFormat{}
	var err error
	if prehook, ok := interface{}(m).(FinancialIntegrationServiceMessageFormatWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(FinancialIntegrationServiceMessageFormatWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type FinancialIntegrationServiceMessageFormat the arg will be the target, the caller the one being converted from

// FinancialIntegrationServiceMessageFormatBeforeToORM called before default ToORM code
type FinancialIntegrationServiceMessageFormatWithBeforeToORM interface {
	BeforeToORM(context.Context, *FinancialIntegrationServiceMessageFormatORM) error
}

// FinancialIntegrationServiceMessageFormatAfterToORM called after default ToORM code
type FinancialIntegrationServiceMessageFormatWithAfterToORM interface {
	AfterToORM(context.Context, *FinancialIntegrationServiceMessageFormatORM) error
}

// FinancialIntegrationServiceMessageFormatBeforeToPB called before default ToPB code
type FinancialIntegrationServiceMessageFormatWithBeforeToPB interface {
	BeforeToPB(context.Context, *FinancialIntegrationServiceMessageFormat) error
}

// FinancialIntegrationServiceMessageFormatAfterToPB called after default ToPB code
type FinancialIntegrationServiceMessageFormatWithAfterToPB interface {
	AfterToPB(context.Context, *FinancialIntegrationServiceMessageFormat) error
}

type SocialServiceMessageFormatORM struct {
	UserId uint64
}

// TableName overrides the default tablename generated by GORM
func (SocialServiceMessageFormatORM) TableName() string {
	return "social_service_message_formats"
}

// ToORM runs the BeforeToORM hook if present, converts the fields of this
// object to ORM format, runs the AfterToORM hook, then returns the ORM object
func (m *SocialServiceMessageFormat) ToORM(ctx context.Context) (SocialServiceMessageFormatORM, error) {
	to := SocialServiceMessageFormatORM{}
	var err error
	if prehook, ok := interface{}(m).(SocialServiceMessageFormatWithBeforeToORM); ok {
		if err = prehook.BeforeToORM(ctx, &to); err != nil {
			return to, err
		}
	}
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(SocialServiceMessageFormatWithAfterToORM); ok {
		err = posthook.AfterToORM(ctx, &to)
	}
	return to, err
}

// ToPB runs the BeforeToPB hook if present, converts the fields of this
// object to PB format, runs the AfterToPB hook, then returns the PB object
func (m *SocialServiceMessageFormatORM) ToPB(ctx context.Context) (SocialServiceMessageFormat, error) {
	to := SocialServiceMessageFormat{}
	var err error
	if prehook, ok := interface{}(m).(SocialServiceMessageFormatWithBeforeToPB); ok {
		if err = prehook.BeforeToPB(ctx, &to); err != nil {
			return to, err
		}
	}
	to.UserId = m.UserId
	if posthook, ok := interface{}(m).(SocialServiceMessageFormatWithAfterToPB); ok {
		err = posthook.AfterToPB(ctx, &to)
	}
	return to, err
}

// The following are interfaces you can implement for special behavior during ORM/PB conversions
// of type SocialServiceMessageFormat the arg will be the target, the caller the one being converted from

// SocialServiceMessageFormatBeforeToORM called before default ToORM code
type SocialServiceMessageFormatWithBeforeToORM interface {
	BeforeToORM(context.Context, *SocialServiceMessageFormatORM) error
}

// SocialServiceMessageFormatAfterToORM called after default ToORM code
type SocialServiceMessageFormatWithAfterToORM interface {
	AfterToORM(context.Context, *SocialServiceMessageFormatORM) error
}

// SocialServiceMessageFormatBeforeToPB called before default ToPB code
type SocialServiceMessageFormatWithBeforeToPB interface {
	BeforeToPB(context.Context, *SocialServiceMessageFormat) error
}

// SocialServiceMessageFormatAfterToPB called after default ToPB code
type SocialServiceMessageFormatWithAfterToPB interface {
	AfterToPB(context.Context, *SocialServiceMessageFormat) error
}

// DefaultCreateHeadlessAuthenticationServiceDeleteAccountMessageFormat executes a basic gorm create call
func DefaultCreateHeadlessAuthenticationServiceDeleteAccountMessageFormat(ctx context.Context, in *HeadlessAuthenticationServiceDeleteAccountMessageFormat, db *gorm.DB) (*HeadlessAuthenticationServiceDeleteAccountMessageFormat, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HeadlessAuthenticationServiceDeleteAccountMessageFormatORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HeadlessAuthenticationServiceDeleteAccountMessageFormatORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type HeadlessAuthenticationServiceDeleteAccountMessageFormatORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HeadlessAuthenticationServiceDeleteAccountMessageFormatORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskHeadlessAuthenticationServiceDeleteAccountMessageFormat patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskHeadlessAuthenticationServiceDeleteAccountMessageFormat(ctx context.Context, patchee *HeadlessAuthenticationServiceDeleteAccountMessageFormat, patcher *HeadlessAuthenticationServiceDeleteAccountMessageFormat, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*HeadlessAuthenticationServiceDeleteAccountMessageFormat, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"AuthnId" {
			patchee.AuthnId = patcher.AuthnId
			continue
		}
		if f == prefix+"Email" {
			patchee.Email = patcher.Email
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListHeadlessAuthenticationServiceDeleteAccountMessageFormat executes a gorm list call
func DefaultListHeadlessAuthenticationServiceDeleteAccountMessageFormat(ctx context.Context, db *gorm.DB) ([]*HeadlessAuthenticationServiceDeleteAccountMessageFormat, error) {
	in := HeadlessAuthenticationServiceDeleteAccountMessageFormat{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HeadlessAuthenticationServiceDeleteAccountMessageFormatORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &HeadlessAuthenticationServiceDeleteAccountMessageFormatORM{}, &HeadlessAuthenticationServiceDeleteAccountMessageFormat{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HeadlessAuthenticationServiceDeleteAccountMessageFormatORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []HeadlessAuthenticationServiceDeleteAccountMessageFormatORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(HeadlessAuthenticationServiceDeleteAccountMessageFormatORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*HeadlessAuthenticationServiceDeleteAccountMessageFormat{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type HeadlessAuthenticationServiceDeleteAccountMessageFormatORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HeadlessAuthenticationServiceDeleteAccountMessageFormatORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type HeadlessAuthenticationServiceDeleteAccountMessageFormatORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]HeadlessAuthenticationServiceDeleteAccountMessageFormatORM) error
}

// DefaultCreateFinancialIntegrationServiceMessageFormat executes a basic gorm create call
func DefaultCreateFinancialIntegrationServiceMessageFormat(ctx context.Context, in *FinancialIntegrationServiceMessageFormat, db *gorm.DB) (*FinancialIntegrationServiceMessageFormat, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialIntegrationServiceMessageFormatORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialIntegrationServiceMessageFormatORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type FinancialIntegrationServiceMessageFormatORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialIntegrationServiceMessageFormatORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskFinancialIntegrationServiceMessageFormat patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskFinancialIntegrationServiceMessageFormat(ctx context.Context, patchee *FinancialIntegrationServiceMessageFormat, patcher *FinancialIntegrationServiceMessageFormat, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*FinancialIntegrationServiceMessageFormat, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListFinancialIntegrationServiceMessageFormat executes a gorm list call
func DefaultListFinancialIntegrationServiceMessageFormat(ctx context.Context, db *gorm.DB) ([]*FinancialIntegrationServiceMessageFormat, error) {
	in := FinancialIntegrationServiceMessageFormat{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialIntegrationServiceMessageFormatORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &FinancialIntegrationServiceMessageFormatORM{}, &FinancialIntegrationServiceMessageFormat{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialIntegrationServiceMessageFormatORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []FinancialIntegrationServiceMessageFormatORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(FinancialIntegrationServiceMessageFormatORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*FinancialIntegrationServiceMessageFormat{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type FinancialIntegrationServiceMessageFormatORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialIntegrationServiceMessageFormatORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type FinancialIntegrationServiceMessageFormatORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]FinancialIntegrationServiceMessageFormatORM) error
}

// DefaultCreateSocialServiceMessageFormat executes a basic gorm create call
func DefaultCreateSocialServiceMessageFormat(ctx context.Context, in *SocialServiceMessageFormat, db *gorm.DB) (*SocialServiceMessageFormat, error) {
	if in == nil {
		return nil, errors.NilArgumentError
	}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SocialServiceMessageFormatORMWithBeforeCreate_); ok {
		if db, err = hook.BeforeCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	if err = db.Create(&ormObj).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SocialServiceMessageFormatORMWithAfterCreate_); ok {
		if err = hook.AfterCreate_(ctx, db); err != nil {
			return nil, err
		}
	}
	pbResponse, err := ormObj.ToPB(ctx)
	return &pbResponse, err
}

type SocialServiceMessageFormatORMWithBeforeCreate_ interface {
	BeforeCreate_(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SocialServiceMessageFormatORMWithAfterCreate_ interface {
	AfterCreate_(context.Context, *gorm.DB) error
}

// DefaultApplyFieldMaskSocialServiceMessageFormat patches an pbObject with patcher according to a field mask.
func DefaultApplyFieldMaskSocialServiceMessageFormat(ctx context.Context, patchee *SocialServiceMessageFormat, patcher *SocialServiceMessageFormat, updateMask *field_mask.FieldMask, prefix string, db *gorm.DB) (*SocialServiceMessageFormat, error) {
	if patcher == nil {
		return nil, nil
	} else if patchee == nil {
		return nil, errors.NilArgumentError
	}
	var err error
	for _, f := range updateMask.Paths {
		if f == prefix+"UserId" {
			patchee.UserId = patcher.UserId
			continue
		}
	}
	if err != nil {
		return nil, err
	}
	return patchee, nil
}

// DefaultListSocialServiceMessageFormat executes a gorm list call
func DefaultListSocialServiceMessageFormat(ctx context.Context, db *gorm.DB) ([]*SocialServiceMessageFormat, error) {
	in := SocialServiceMessageFormat{}
	ormObj, err := in.ToORM(ctx)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SocialServiceMessageFormatORMWithBeforeListApplyQuery); ok {
		if db, err = hook.BeforeListApplyQuery(ctx, db); err != nil {
			return nil, err
		}
	}
	db, err = gorm1.ApplyCollectionOperators(ctx, db, &SocialServiceMessageFormatORM{}, &SocialServiceMessageFormat{}, nil, nil, nil, nil)
	if err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SocialServiceMessageFormatORMWithBeforeListFind); ok {
		if db, err = hook.BeforeListFind(ctx, db); err != nil {
			return nil, err
		}
	}
	db = db.Where(&ormObj)
	ormResponse := []SocialServiceMessageFormatORM{}
	if err := db.Find(&ormResponse).Error; err != nil {
		return nil, err
	}
	if hook, ok := interface{}(&ormObj).(SocialServiceMessageFormatORMWithAfterListFind); ok {
		if err = hook.AfterListFind(ctx, db, &ormResponse); err != nil {
			return nil, err
		}
	}
	pbResponse := []*SocialServiceMessageFormat{}
	for _, responseEntry := range ormResponse {
		temp, err := responseEntry.ToPB(ctx)
		if err != nil {
			return nil, err
		}
		pbResponse = append(pbResponse, &temp)
	}
	return pbResponse, nil
}

type SocialServiceMessageFormatORMWithBeforeListApplyQuery interface {
	BeforeListApplyQuery(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SocialServiceMessageFormatORMWithBeforeListFind interface {
	BeforeListFind(context.Context, *gorm.DB) (*gorm.DB, error)
}
type SocialServiceMessageFormatORMWithAfterListFind interface {
	AfterListFind(context.Context, *gorm.DB, *[]SocialServiceMessageFormatORM) error
}
